# if you ran into trouble, try seting wxRoot, glewRoot and boostRoot to the root directories of the assosiated libraries.
# please set them from a different CMakeLists file, and call add_subdirectory on this project directorie.
#
# wxwidgets - wxRoot - REQUIRED 
# glew - glewRoot - REQUIRED 
# boost - boostRoot - optioanall 
#
# if you want a stackTrace in debugging, set the following: (not in this file)
# add_definitions( -DUSE_STACKTRACE=1 )
#
# for MinGW builds:
# cmake -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=<Debug/Release ... etk> -B <target dir>
# for msvc build:
# cmake -B <target dir> --config <Debug/release ... etk>


project(3d-laser-room)
cmake_minimum_required(VERSION 2.9...3.22.1)
aux_source_directory(. SRC_LIST)
include_directories(${PROJECT_SOURCE_DIR}) # mingw doesnt pick this up by default

add_executable(${PROJECT_NAME} ${SRC_LIST})
target_compile_features(${PROJECT_NAME} PRIVATE cxx_std_17)

find_package(OpenGL REQUIRED)
target_link_libraries(${PROJECT_NAME} opengl32)

# wxwidgets
find_package(wxWidgets COMPONENTS core base gl)
if(wxWidgets_FOUND)
	include(${wxWidgets_USE_FILE})	
	target_link_libraries(${PROJECT_NAME} ${wxWidgets_LIBRARIES})

	string(REGEX MATCHALL ".*dll.*;" base "${wxWidgets_INCLUDE_DIRS}")
	cmake_path(GET base PARENT_PATH base)
	
	# copy required dlls
	if(WIN32)
	file(GLOB globed ${base}/*.dll)
	string(REGEX MATCH "wx[^\/]+u_core[^\/]+\.dll" ar "${globed}")
	string(REGEX MATCH "wx[^\/]+u_vc[^\/]+\.dll" br "${globed}")
	string(REGEX MATCH "wx[^\/]+u_gl[^\/]+\.dll" cr "${globed}")
	string(REGEX MATCH "wx[^\/]+ud_core[^\/]+\.dll" ad "${globed}")
	string(REGEX MATCH "wx[^\/]+ud_vc[^\/]+\.dll" bd "${globed}")
	string(REGEX MATCH "wx[^\/]+ud_gl[^\/]+\.dll" cd "${globed}")
	add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD COMMAND ${CMAKE_COMMAND}
	-E copy "${base}/$<IF:$<CONFIG:Debug>,${ad},${ar}>" "$<TARGET_FILE_DIR:${PROJECT_NAME}>" )	
	add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD COMMAND ${CMAKE_COMMAND}
	-E copy "${base}/$<IF:$<CONFIG:Debug>,${bd},${br}>" "$<TARGET_FILE_DIR:${PROJECT_NAME}>" )
	add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD COMMAND ${CMAKE_COMMAND}
	-E copy "${base}/$<IF:$<CONFIG:Debug>,${cd},${cr}>" "$<TARGET_FILE_DIR:${PROJECT_NAME}>" )
	endif()
else()
	
	if(EXISTS ${wxRoot}/lib AND EXISTS ${wxRoot}/include) 
	
		FILE(GLOB wxLibDir ${wxRoot}/lib/*)	
		message(STATUS "searching wxWidgets libraries in: ${wxLibDir}")
		
		FILE(GLOB a ${wxLibDir}/*)	
		foreach(X IN LISTS a)
			if(IS_DIRECTORY ${X})
				include_directories(${X})
			endif()
		endforeach()

		message(STATUS "foud wxWidgets via {wxRoot}")
		file(GLOB wxlib "${wxLibDir}/*.lib")
		file(GLOB wxlib "${wxLibDir}/*.a")
		include_directories(${PROJECT_NAME} PRIVATE "${wxRoot}/include")
		target_link_libraries(${PROJECT_NAME} ${wxlib})

		# copy required dlls
		if(WIN32)
		file(GLOB globed ${wxLibDir}/*.dll)
		string(REGEX MATCH "wx[^\/]+u_core[^\/]+\.dll" ar "${globed}")
		string(REGEX MATCH "wx[^\/]+u_vc[^\/]+\.dll" br "${globed}")
		string(REGEX MATCH "wx[^\/]+u_gl[^\/]+\.dll" cr "${globed}")
		string(REGEX MATCH "wx[^\/]+ud_core[^\/]+\.dll" ad "${globed}")
		string(REGEX MATCH "wx[^\/]+ud_vc[^\/]+\.dll" bd "${globed}")
		string(REGEX MATCH "wx[^\/]+ud_gl[^\/]+\.dll" cd "${globed}")
		add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD COMMAND ${CMAKE_COMMAND}
		-E copy "${wxLibDir}/$<IF:$<CONFIG:Debug>,${ad},${ar}>" "$<TARGET_FILE_DIR:${PROJECT_NAME}>" )	
		add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD COMMAND ${CMAKE_COMMAND}
		-E copy "${wxLibDir}/$<IF:$<CONFIG:Debug>,${bd},${br}>" "$<TARGET_FILE_DIR:${PROJECT_NAME}>" )
		add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD COMMAND ${CMAKE_COMMAND}
		-E copy "${wxLibDir}/$<IF:$<CONFIG:Debug>,${cd},${cr}>" "$<TARGET_FILE_DIR:${PROJECT_NAME}>" )
		add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD COMMAND ${CMAKE_COMMAND}
		-E copy "${wxLibDir}/$<IF:$<CONFIG:Debug>,wxbase316ud_gcc_custom.dll,wxbase316u_gcc_custom.dll>" "$<TARGET_FILE_DIR:${PROJECT_NAME}>" )	
		endif()
	else() 
		message(FATAL_ERROR "cannot find wxWidgets in anny way")
	endif()
	
endif(wxWidgets_FOUND)


# glew
# glew doesn't play well with cmake, this is a workaround. 
# works on win10, Visual Studio 16 2019 compiler and minGW compiler, cmake version 3.16.3.
# it just gets the glew installd path from ${GLEW_DIR} and uses it afterward.
find_package(GLEW)
if(GLEW_FOUND)
	set(glew_dir ${GLEW_DIR})
	string(REPLACE "/lib/cmake/glew" "" glew_dir2 ${GLEW_DIR})
	target_include_directories(${PROJECT_NAME} PRIVATE ${glew_dir}/include)
	if(WIN32) 
		target_link_libraries(${PROJECT_NAME} ${glew_dir2}/lib/*.lib)
	else() 
		target_link_libraries(${PROJECT_NAME} ${glew_dir2}/lib/*.a)
	endif()
else()
	if(EXISTS ${glewRoot})
		if(EXISTS ${glewRoot}/lib AND EXISTS ${glewRoot}/include) 
			message(STATUS "foud glew via {glewRoot}")
		else() 
			message(FATAL_ERROR "cannot find glew in anny way")
		endif()
		
		include_directories(${PROJECT_NAME} PRIVATE "${glewRoot}/include")

		file(GLOB globed2 ${glewRoot}/bin/*.dll)
		
		# this commented section is if debug builds ask for debug version of glew wich they dont.
		#string(REGEX MATCHALL "glew[^\/]+[^d]\.dll" glewr "${globed2}")
		#string(REGEX MATCHALL "glew[^\/]+d\.dll" glewd "${globed2}")
		#add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD COMMAND ${CMAKE_COMMAND}
		#-E copy "${glewRoot}/bin/$<IF:$<CONFIG:Debug>,${glewd},${glewr}>" "$<TARGET_FILE_DIR:${PROJECT_NAME}>" )	
		string(REGEX MATCHALL "glew[^\/]+[^d]\.dll" glewr "${globed2}")
		add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD COMMAND ${CMAKE_COMMAND}
		-E copy "${glewRoot}/bin/$<IF:$<CONFIG:Debug>,${glewr},${glewr}>" "$<TARGET_FILE_DIR:${PROJECT_NAME}>" )
		
		if(WIN32) 
			file(GLOB glewlib "${glewRoot}/lib/*.lib")
		else()
			file(GLOB glewlib "${glewRoot}/lib/*.a")
		endif()
		target_link_libraries(${PROJECT_NAME} ${glewlib})
	else()
		message(FATAL_ERROR "cannot find glew, try to set {glewlib} to glew root directorie")
	endif()
endif(GLEW_FOUND)


find_package(Boost)
if(BOOST_FOUND)
	target_include_directories(${PROJECT_NAME} PRIVATE ${Boost_INCLUDE_DIRS})
else()
	if(EXISTS ${boostRoot})
		target_include_directories(${PROJECT_NAME} PUBLICK ${boostRoot})
	elseif(EXISTS ${boostRoot})
		message(STATUS "cannot find boostRoot, try to set boostRoot to boost root directorie")
	endif()
endif()


# in case release, compiles as desktop app. debug gets a console.
if(NOT MINGW AND WIN32)
	target_link_options(${PROJECT_NAME} PUBLIC "$<$<CONFIG:Release>:/SUBSYSTEM:WINDOWS>")
endif()

# copy res dir to build dir
add_custom_command(
  TARGET ${PROJECT_NAME} POST_BUILD
  COMMAND ${CMAKE_COMMAND}
  ARGS -E copy_directory "${CMAKE_CURRENT_SOURCE_DIR}/res" "$<TARGET_FILE_DIR:${PROJECT_NAME}>/res"
)


	  
# precompile pch.h
target_precompile_headers(${PROJECT_NAME} PRIVATE pch.h)




